# Массив

1	concat()	Объединяет массивы и элементы  
2	push()	Добавляет элементы в конец массива  
3	pop()	Удаляет последний элемент массива и возвращает его значение  
4	unshift()	Добавляет элементы в начало массива  
5	shift()	Удаляет первый элемент массива и возвращает его значение  
6	slice()	Копирует часть массива и создаёт из неё новый массив  
7	splice()	Удаляет часть элементов, а на их место ставит новые  
8	forEach()	Перебирает элементы, выполняя для каждого какой-то код  
9	map()	Создаёт новый массив, получая каждый элемент из уже имеющегося массива  
10	filter()	Создаёт новый массив, выкидывая из исходного элементы по заданным правилам  
11	some()	Проверяет, есть ли в массиве хоть один элемент, соответствующий заданному правилу  
12	every()	Проверяет, все ли элементы массива соответствуют заданному правилу  
13	find()	Проверяет, есть ли в массиве определённый элемент  
14	reduce()	Сводит массив к какому-то одному значению  
15	sort()	Сортирует массив  

- __.concat()__ - Метод применяется к массиву и создаёт из него новый. Все аргументы, переданные методу, будут добавлены в новый массив в том же порядке:
```javascript
const toDoList = ['Посадить дерево', 'Построить дом'];
const toDoListUpdated = toDoList.concat('Вырастить сына');

console.log(toDoListUpdated);

// ["Посадить дерево", "Построить дом", "Вырастить сына"]
```
Как аргумент можно передать и другой массив — его элементы будут скопированы и добавлены в новый массив:
```javascript
const moscowAttractions = ['Кремль', 'Третьяковская галерея'];
const spbAttractions = ['Эрмитаж', 'Мариинский театр'];
const volgogradAttractions = ['Мамаев Курган', 'Родина-мать'];

const russiaAttractions = moscowAttractions.concat(spbAttractions, volgogradAttractions);

// получим новый массив со значениями всех исходных массивов

console.log(russiaAttractions);

/*
  [
    "Кремль",
    "Третьяковская галерея",
    "Эрмитаж",
    "Мариинский театр",
    "Мамаев Курган",
    "Родина-мать"
  ]
*/
```
ссылки: [Яндекс Практикум](https://practicum.yandex.ru/learn/frontend-developer/courses/6099140a-985c-4b15-a7b9-a6a0e18c93eb/sprints/145379/topics/981c9561-2b1c-4be4-a2a3-2d661757f07f/lessons/b3a9fc16-a87b-463d-91ed-c23bd4425a8f/), [learn.javascript](https://learn.javascript.ru/array-methods), [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)

- __.join()__ - Метод создаёт строку из элементов массива, разделённых запятой:
```javascript
const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];

console.log(bremenMusicians.join());

// "Кот,Пёс,Трубадур,Осёл,Петух"

console.log(`Представляем музыкантов: ${bremenMusicians.join(', ')}`);
// "Представляем музыкантов: Кот, Пёс, Трубадур, Осёл, Петух"

// при этом с исходным массивом ничего не произошло:
console.log(bremenMusicians);
// ["Кот", "Пёс", "Трубадур", "Осёл", "Петух"]
```
Если не передать join аргумент, элементы в строке будут перечислены через запятую. Но мы можем задать любой нужный разделитель:
```javascript
const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];

console.log(bremenMusicians.join(' | '));

// "Кот | Пёс | Трубадур | Осёл | Петух"
```
ссылки: [Яндекс Практикум](https://practicum.yandex.ru/learn/frontend-developer/courses/6099140a-985c-4b15-a7b9-a6a0e18c93eb/sprints/145379/topics/981c9561-2b1c-4be4-a2a3-2d661757f07f/lessons/b3a9fc16-a87b-463d-91ed-c23bd4425a8f/), [learn.javascript](https://learn.javascript.ru/array-methods), [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join)

- __.push()__ - Метод добавляет переданные ему аргументы в конец массива:
```javascript
const emeraldCityHeroes = ['Лев', 'Дровосек', 'Страшила'];
emeraldCityHeroes.push('Элли', 'Тотошка');

console.log(emeraldCityHeroes);

// ["Лев", "Дровосек", "Страшила", "Элли", "Тотошка"]
```

- __pop__ - Метод удаляет последний элемент массива. Он не принимает аргументы — только возвращает значение удалённого элемента. Если массив пуст, pop вернёт undefined:
```javascript
const insects = ['Бабочка', 'Мотылёк', 'Божья коровка', 'Комар'];

console.log(insects.pop()); // "Комар"
console.log(insects); // ["Бабочка", "Мотылёк", "Божья коровка"]
```

- __.shift()__ - Метод удаляет первый элемент массива. Исходный массив при этом изменится:
```javascript
const italyCities = ['Помпеи', 'Рим', 'Неаполь'];

const volcanoEruption = italyCities.shift();

// метод shift() возвращает удалённый элемент
console.log(volcanoEruption); // "Помпеи"

// массив остался без первого элемента
console.log(italyCities); // ["Рим", "Неаполь"]

// если массив изначально пустой, вернётся undefined:
const emptyArr = [];

console.log(emptyArr.shift()); // undefined
```

- __.unshift()__ - Метод добавляет элементы в начало массива. Их передают через запятую:
```javascript
const queue = ['Рабочие', 'Школьники', 'Студенты'];

queue.unshift('Пенсионеры', 'Инвалиды');

console.log(queue);

// ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"]
```
Метод unshift изменит исходный массив и напишет, сколько элементов в новом массиве:
```javascript
const queue = ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"];

console.log(queue.length); // 5
console.log(queue.unshift('Мне только спросить')); // 6
```

- __.slice()__ - Метод копирует часть массива и делает из неё новый массив. Он принимает на вход два аргумента:  
  * индекс элемента, с которого нужно начать копирование (включительно);  
  * индекс элемента, на котором нужно остановиться (не включительно).  
  
Исходный массив при этом не изменяется:
```javascript
const months = [
  'Январь',
  'Февраль',
  'Март',
  'Апрель',
  'Май',
  'Июнь',
  'Июль',
  'Август',
  'Сентябрь',
  'Октябрь',
  'Ноябрь',
  'Декабрь'
];

// начиная с индекса 2 ("Март") и до, но не включая индекс 5 ("Июнь")
const spring = months.slice(2, 5);

console.log(spring); // ["Март", "Апрель", "Май"]

console.log(months); /* ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"] */

// Как видите, исходный массив остался нетронутым
```
Можно передавать как аргумент и отрицательные числа. Тогда индекс будет считаться с конца массива:
```javascript
const months = [
  'Январь',
  'Февраль',
  'Март',
  'Апрель',
  'Май',
  'Июнь',
  'Июль',
  'Август',
  'Сентябрь',
  'Октябрь',
  'Ноябрь',
  'Декабрь'
];

// начиная с четвёртого элемента с конца и до первого с конца (не включительно)
const autumn = months.slice(-4, -1);
console.log(autumn); // ["Сентябрь", "Октябрь", "Ноябрь"]

// с третьего элемента с конца и до конца
const fourthQuarter = months.slice(-3);
console.log(fourthQuarter); // ["Октябрь", "Ноябрь", "Декабрь"]
```

- __.splice()__ - Метод splice выполняет два действия: удаляет элементы из массива и добавляет на их место новые.  
  * Первый аргумент метода — индекс элемента, с которого надо начать удалять.  
  * Второй — сколько элементов нужно удалить.  
  * Аргументы с третьего — элементы, которые мы хотим поставить на место удалённых. Их может быть сколько угодно или не быть вообще:
```javascript
const week = [
  'Понедельник',
  'Вторник',
  'Среда',
  'Четверг',
  'Пятница',
  'Суббота',
  'Воскресенье'
];

// начиная с индекса 0 удалим пять элементов и вставим на их место другие пять
const removedItems = week.splice(0, 5, 'Воскресенье', 'Суббота', 'Воскресенье', 'Суббота', 'Воскресенье');

console.log(removedItems); // ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница"]

console.log(week); // ["Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье"]
```
Этот код изменит исходный массив и вернёт новый из удалённых элементов. Новые значения добавлять необязательно — можно удалить существующие. И наоборот. Можно ничего не удалять — только добавить новые элементы.

- __Array.from()__ - Создаёт массив из «массивоподобного» объекта:
```javascript
const posts = content.querySelectorAll('.post');

const postsArray = Array.from(posts); // такой вызов вернёт полноценный массив
```
Объект считается массивоподобным, если: его элементы имеют числовые индексы, у него есть свойство length.

- __.forEach(function (){})__ - Метод нужен для обхода массива. В качестве аргумента forEach принимает функцию. Она будет вызвана на каждом элементе массива поочерёдно:
```javascript
const how = ['быстрее', 'выше', 'сильнее'];

how.forEach(function (item) {
    console.log(item + '.');
});

/*
  быстрее.
  выше.
  сильнее.
*/
```
Метод  forEach удобно использовать для работы с массивоподобными объектами. Например, с NodeList. Частая задача — пройтись по нескольким DOM элементам, вызвав для каждого из них функцию:
```javascript
const elements = document.querySelectorAll('.text');

elements.forEach((item) => {
   item.classList.add('text_is-active');
});
```
Метод forEach — более удобная для работы с массивом версия цикла for. Но с forEach нельзя использовать директивы continue и break.

- __.map(function (){})__ - Метод создаёт новый массив на основе существующего. В качестве аргумента map, как и forEach, принимает функцию. Эта функция должна вернуть значение, которое станет элементом нового массива.
```javascript
const firstArr = [0, 1, 2, 3, 4];

const secondArr = firstArr.map(function (item) { // Берём каждый элемент массива
  return item * item; // Возводим каждый элемент в квадрат
}); 

console.log(secondArr); // [0, 1, 4, 9, 16]
```
Результат работы функции — то, что указано после ключевого слова __return__. Если не прописать __return__, функция сработает, но вернёт _undefined_.  
Метод __map__ нельзя применить к массивоподобным объектам.  
Если функцию передают как аргумент, её называют «колбэком».  
Колбэк, который мы передаём методам __forEach__ и __map__, при каждом исполнении получает три аргумента. Разберём, что это за аргументы и зачем они нужны.  
#### Аргумент 1. Текущий элемент массива
```javascript
const positions = [
  'Великий Умывальник',
  'Знаменитый Мойдодыр',
  'Умывальников Начальник',
  'Мочалок Командир'
];

/* Переданный колбэк будет вызван 4 раза.
По очереди с каждым элементом массива positions */

positions.forEach(function(item) {
  console.log(item);
});

/*
  Великий Умывальник
  Знаменитый Мойдодыр
  Умывальников Начальник
  Мочалок Командир
*/
```
#### Аргумент 2. Индекс текущего элемента
Второй аргумент колбэка — счётчик. Его можно использовать, например, для расстановки позиций в списке:
```javascript
const counter = [
  'Царь',
  'Царевич',
  'Король',
  'Королевич',
  'Сапожник',
  'Портной'
];

const counterIndexed = counter.map(function (person, index) {
    return `${index + 1}. ${person}`;
});

console.log(counterIndexed);

/*
[
  "1. Царь",
  "2. Царевич",
  "3. Король",
  "4. Королевич",
  "5. Сапожник",
  "6. Портной"
]
*/
```
#### Аргумент 3. Исходный массив
Исходный массив как аргумент пригодится, когда нужно обратиться к свойствам этого исходного массива:
```javascript
const ivans = [
  'Иван I Калита',
  'Иван II  Красный',
  'Иван III Великий',
  'Иван IV Грозный',
  'Иван V',
  'Иван VI'
];

const ivansIndexed = ivans.map(function(item, index, array) {
  const currentIndex = `(${(index + 1)} из ${array.length})`;
  return `${item} ${currentIndex}`;
});

console.log(ivansIndexed);

/*
[
  "Иван I Калита (1 из 6)",
  "Иван II  Красный (2 из 6)",
  "Иван III Великий (3 из 6)",
  "Иван IV Грозный (4 из 6)",
  "Иван V (5 из 6)",
  "Иван VI (6 из 6)"
]
*/
```

- __.filter(function (){})__ - Метод отсеивает элементы массива по заданному признаку. Как __forEach__ и __map__, метод __filter__ принимает колбэк в качестве аргумента. Этот колбэк будет вызван на каждом элементе. Он должен вернуть _true_ или _false_ в зависимости от того, хотим мы оставить текущий элемент массива или отфильтровать:
```javascript
const a = [1, 9, 2, 2, 3, 4, 1, 7, 8, 0, 9, 0, 1, 5, 3];

// отберём элементы больше 5
const b = a.filter(function (item) {
  return item > 5
});

console.log(b); // [9, 7, 8, 9]
```
Метод __filter__ создаёт новый массив из элементов, для которых функция-фильтр вернула _true_. При этом исходный массив не меняется.  
Колбэк метода __filter__ — те же три параметра, что и у __map__ и __forEach__. Текущий элемент, его индекс и исходный массив.

- __.some(function (){})__ - Метод проверяет, есть ли в массиве хотя бы один элемент, который соответствует определённому правилу. Колбэк с этим правилом проверяет каждый элемент и возвращает _true_ или _false_:
```javascript
const oceanResidents = ['Флаундер', 'Немо', 'Губка Боб', 'Аквамен'];

const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
});

console.log(nemo); // true
```
Колбэк принимает на вход всё те же аргументы:  
  * текущий элемент массива,
  * его индекс,  
  * сам исходный массив.  
  
Метод some начинает проверку с первого элемента и продолжает, пока не встретит первое значение, для которого колбэк вернёт _true_. Если оно найдено, метод прекратит проверку и тоже вернёт _true_. Если нет — вернёт _false_:
```javascript
const haystack = ['сено', 'сено', 'сено', 'сено', 'сено', 'сено'];

const needle = haystack.some(function(item) {
    return item === 'иголка';
});

console.log(needle); // false
```

- __.find(function (){})__ - Метод очень похож на __some__. Единственное отличие: __some__ возвращает булево значение, а __find__ — значение элемента, на котором он завершил проверку:
```javascript
const birds = [
    'Ворона',
    'Чёрно-белая ворона',
    'Белая ворона',
    'Ворона обыкновенная'
];

const includesCrow = birds.some(function (bird) {
    return bird.includes('ворона');
});

const crow = birds.find(function (bird) {
    return bird.includes('ворона');
});

console.log(includesCrow); // true
console.log(crow); // "Чёрно-белая ворона"
```

- __.find(function (){})__ - Метод тоже похож на __some__, но проверяет все элементы массива и возвращает __true_, только если все элементы прошли проверку.
Колбэк — единственный аргумент метода. Он содержит логику проверки каждого элемента и возвращает _true_ или _false_:
```javascript
const jokes = [
  'смешная шутка и доля правды',
  'не очень смешной анекдот + доля правды',
  'доля правды в дурацкой шутке, услышав которую, все улыбнулись из вежливости'
];

const allJokesWithTruth = jokes.every(function (joke) {
  return joke.indexOf('доля правды') > -1;
});

console.log(allJokesWithTruth); // true
```
Если по мере перебора элементов колбэк возвращает _false_, метод every завершает проверку и тоже возвращает _false_.

- __.reduce()__ - Метод перебирает элементы массива и сводит его к одному значению. У колбэка reduce четыре аргумента.
##### Новый аргумент. Промежуточное значение
Промежуточное значение — новый первый аргумент и главная особенность __reduce__. На каждой итерации этот аргумент равен тому, что в прошлый раз вернул _колбэк_.
```javascript
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const sum = arr.reduce(function (previousValue, item) {
  // для наглядности выведем аргументы в консоль
  console.log(`previousValue: ${previousValue}, item: ${item}`);
  return previousValue + item;
});

console.log(`sum: ${sum}`);

/*
 previousValue: 1, item: 2
 previousValue: 3, item: 3
 previousValue: 6, item: 4
 previousValue: 10, item: 5
 previousValue: 15, item: 6
 previousValue: 21, item: 7
 previousValue: 28, item: 8
 previousValue: 36, item: 9
 sum: 45
*/
```
На первой итерации значение _previousValue_ — первый элемент массива, _item_ — второй. На второй итерации _previousValue_ — сумма первых двух элементов, _item_ — третий элемент. После последнего _item_ в _sum_ будет итоговая сумма всех элементов массива.  
__Суть метода reduce__  
Как работает метод _reduce_:  
  * сводит массив к одному значению: числу, массиву, объекту;  
  * принимает на вход 2 аргумента: обязательный колбэк и исходное значение его первого аргумента;  
  * содержит в колбэке 4 аргумента: промежуточное значение, текущий элемент, его индекс и сам исходный массив.  
ссылки: [Яндекс Практикум](https://practicum.yandex.ru/trainer/frontend-developer/lesson/87d2b86b-d870-4ca8-be13-dfe276ff0b62/task/dff592cc-2a34-4a41-996b-c49e337037d7/)

- __.sort__ - Метод принимает на вход колбэк. Но для других методов колбэк обязателен, а для _sort_ нет:
```javascript
const myNumbers = [0, 3.14, 2.718, 13];
myNumbers.sort();
myNumbers; // [0, 13, 2.718, 3.14]
```
Метод _sort_ работал с элементами массива как со строками. Будь это слова, они бы выстроились по алфавиту:
```javascript
const fruits = ['яблоко', 'банан', 'апельсин', 'томат'];
fruits.sort(); // ["апельсин", "банан", "томат", "яблоко"]
```
В алфавите нет цифр, чтобы их сортировать. Но в JS каждый символ зашифрован в системе Unicode. Любой букве, числу и знаку соответствует какой-то код. Метод sort, если не передавать ему аргументы, пытается сортировать элементы массива по возрастанию этих кодов.  
Любой алгоритм сортировки — последовательное сравнение двух элементов. Один из них будет стоять в итоговом массиве раньше, другой — позже. Логику, по которой элементы будут сравниваться, описывают внутри колбэка метода sort.  
Колбэк принимает на вход два аргумента — два элемента массива, которые предстоит сравнивать. Способ сравнения нужно описать в колбэке. Метод sort расставляет элементы исходя из значения, которое возвращает колбэк.  
Есть ограничение: колбэк обязан возвращать число. Оно может быть:  
  * Меньше нуля — первый элемент, переданный как аргумент колбэка, встанет в массиве раньше второго.
  * Больше нуля — наоборот, второй элемент окажется раньше первого.
  * Равно нулю — порядок не изменится, элементы будут стоять как в исходном массиве.  
```javascript
const myNumbers = [0, 3.14, 2.718, 13];

myNumbers.sort(function (a, b) {
    return a - b;

  /* Если a меньше b, вернётся отрицательное число.
  Это значит, что a должно расположиться в итоговом массиве
  раньше, b — позже. Например:

    a = 0, b = 3.14
    a - b = -3.14

  Получили отрицательное число, значит a стоит раньше b */
});

console.log(myNumbers); // [0, 2.718, 3.14, 13] — так и есть
```
Для чисел такой подход отлично работает: если вы хотите отсортировать массив по возрастанию, колбэк должен возвращать a - b, по убыванию — b - a.  
Если же элементы массива — строки. Придётся указывать, какая строка считается «большей», а какая — «меньшей», и прописывать для разных случаев возвращаемое значение:
```javascript
/* Диагнозы записаны в том порядке,
в каком поступили пациенты. Отсортируем его по алфавиту. */

const diagnoses = [
  'мизофобия',
  'синдром упущенной выгоды',
  'боязнь красного цвета'
];

diagnoses.sort(function(a, b) {
  /* приведём строки к нижнему регистру,
  чтобы сравнение прошло корректно */
  a = a.toLowerCase();
  b = b.toLowerCase();

    if (a < b) return -1; // a расположится раньше b
    if (b < a) return 1; // b расположится раньше a

  return 0;
});

console.log(diagnoses);

/* ["боязнь красного цвета", "мизофобия", "синдром упущенной выгоды"] */
```